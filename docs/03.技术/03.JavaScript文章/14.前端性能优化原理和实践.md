---
title: 前端性能优化原理和实践
date: 2021-02-26 15:02:26
permalink: /pages/7c6098/
categories:
  - 技术
  - JavaScript文章
tags:
  - 
---
### 从输入 URL 到页面加载完成，发生了什么？

1. DNS 解析
2. TCP 连接
3. HTTP 请求抛出
4. 服务端处理请求，HTTP 响应返回
5. 浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户

*大家谨记，我们任何一个用户端的产品，都需要把这 5 个过程滴水不漏地考虑到自己的性能优化方案内、反复权衡，从而打磨出用户满意的速度*

### 知识图谱

<div align=center>
<img width="800" src="https://user-gold-cdn.xitu.io/2018/10/23/1669f5358f63c0f8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
</div>


### HTTP 优化
- 减少请求次数
- 减少单次请求所花费的时间

*这两个优化点直直地指向了我们日常开发中非常常见的操作——资源的压缩与合并*

#### webpack 的优化瓶颈，主要是两个方面：

- webpack 的构建过程太花时间
- webpack 打包的结果体积太大

#### 优化方案

1. include 或 exclude 来帮我们避免不必要的转译
2. 用 DllPlugin 处理文件  
>*这个插件会把第三方库单独打包到一个文件中，这个文件就是一个单纯的依赖库,这个依赖库不会跟着你的业务代码一起被重新打包，只有当依赖自身发生版本变化时才会重新打包*
3. Happypack——将 loader 由单进程转为多进程
4. 文件结构可视化，找出导致体积过大的原因
>*webpack-bundle-analyzer*
5. 删除冗余代码 (Tree-Shaking)(UglifyJsPlugin)
6. 按需加载
7. Gzip 压缩

### 图片优化

*为在不同的业务场景下使用合适的图片类型，从而达到在压缩图片体积实现优化的同时尽量保证质量*

### 浏览器缓存

- 首先通过 Cache-Control 验证强缓存是否可用如果强缓存可用，直接使用
- 否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的If-Modified-Since或者If-None-Match这些条件请求字段检查资源是否更新
- 若资源更新，返回资源和200状态码
- 否则，返回304，告诉浏览器直接从缓存获取资源

#### 本地存储

- Cookie
- Web Storage
- IndexedDB 

> 是一个运行在浏览器上的非关系型数据库。既然是数据库了，那就不是 5M、10M 这样小打小闹级别了。理论上来说，IndexedDB 是没有存储上限的（一般来说不会小于 250M）。它不仅可以存储字符串，还可以存储二进制数据

#### CDN的缓存

>CDN （Content Delivery Network，即内容分发网络）指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。 CDN 提供快速服务，较少受高流量影响。

### 渲染优化

#### 告别阻塞：CSS 与 JS 的加载顺序优化

>默认情况下，CSS 是阻塞的资源。浏览器在构建 CSSOM 的过程中，不会渲染任何已处理的内容。即便 DOM 已经解析完毕了，只要 CSSOM 不 OK，那么渲染这个事情就不 OK（这主要是为了避免没有 CSS 的 HTML 页面丑陋地“裸奔”在用户眼前）。

#### 服务端渲染

>服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串，然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容，不需要为了生成 DOM 内容自己再去跑一遍 JS 代码。

>JS 的作用在于修改，它帮助我们修改网页的方方面面：内容、样式以及它如何响应用户交互。这“方方面面”的修改，本质上都是对 DOM 和 CSSDOM 进行修改。因此 JS 的执行会阻止 CSSOM，在我们不作显式声明的情况下，它也会阻塞 DOM

#### JS的三种加载方式

- 正常模式：

 ```js
  <script src="index.js"></script>
```
  *这种情况下 JS 会阻塞浏览器，浏览器必须等待 index.js 加载和执行完毕才能去做其它事情。*
  
- async 模式：

 ```js
  <script async src="index.js"></script>
```
  *async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会立即执行。*
- defer 模式：

 ```js
  <script defer src="index.js"></script>
```
  *defer 模式下，JS 的加载是异步的，执行是被推迟的。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行。*



> 从应用的角度来说，一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 `async`；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 `defer。`
> 
<div align=center>
<img width="800" src="https://user-gold-cdn.xitu.io/2018/9/26/166162c1cbad2c64?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
</div>

##### 优势
*优势1: 利于seo, 优势2: 加快首屏加载速度*


### 浏览器背后的运行机制

- HTML 解释器：将 HTML 文档经过词法分析输出 DOM 树。

- CSS 解释器：解析 CSS 文档, 生成样式规则。

- 图层布局计算模块：布局计算每个对象的精确位置和大小。

- 视图绘制模块：进行具体节点的图像绘制，将像素渲染到屏幕上。

- JavaScript 引擎：编译执行 Javascript 代码。