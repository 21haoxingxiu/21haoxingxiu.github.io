(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{523:function(t,e,o){"use strict";o.r(e);var a=o(15),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h3",{attrs:{id:"类组件与函数组件有什么区别呢"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#类组件与函数组件有什么区别呢"}},[t._v("#")]),t._v(" 类组件与函数组件有什么区别呢？")]),t._v(" "),o("ol",[o("li",[o("p",[t._v("作为组件而言，类组件与函数组件在使用与呈现上没有任何不同，性能上在现代浏览器中也不会有明显差异。")])]),t._v(" "),o("li",[o("p",[t._v("它们在开发时的心智模型上却存在巨大的差异。类组件是基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是 immutable、没有副作用、引用透明等特点。")])]),t._v(" "),o("li",[o("p",[t._v("之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。")])]),t._v(" "),o("li",[o("p",[t._v("但现在由于 React Hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。")])]),t._v(" "),o("li",[o("p",[t._v("其次继承并不是组件最佳的设计模式，官方更推崇“组合优于继承”的设计概念，所以类组件在这方面的优势也在淡出。")])]),t._v(" "),o("li",[o("p",[t._v("性能优化上，类组件主要依靠 shouldComponentUpdate 阻断渲染来提升性能，而函数组件依靠 React.memo 缓存渲染结果来提升性能。")])]),t._v(" "),o("li",[o("p",[t._v("从上手程度而言，类组件更容易上手，从未来趋势上看，由于React Hooks 的推出，函数组件成了社区未来主推的方案。")])]),t._v(" "),o("li",[o("p",[t._v("类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展")])])]),t._v(" "),o("p",[o("img",{attrs:{src:"https://raw.githubusercontent.com/21haoxingxiu/picture/master/blog/20210302211821.png",alt:""}})])])}),[],!1,null,null,null);e.default=s.exports}}]);